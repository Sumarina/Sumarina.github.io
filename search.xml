<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>深入了解webpack配置（一）</title>
      <link href="/2020/03/27/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3webpack%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/03/27/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3webpack%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack-是什么"><a href="#webpack-是什么" class="headerlink" title="webpack 是什么"></a>webpack 是什么</h2><p>webpack 是一个静态资源构建工具，主要是把我们的应用程序所需要的模块构建成一个或者多个 bundles。在构建过程中，webpack 会递归循环创建依赖关系图。</p><h2 id="webpack-的核心概念"><a href="#webpack-的核心概念" class="headerlink" title="webpack 的核心概念"></a>webpack 的核心概念</h2><ol><li>entry（入口）：指示 webpack 构建的入口文件，也就是构建依赖关系图的开始。（默认值为<code>./src</code>）</li><li>output（输出）：输出构建之后的 bundles（可以修改输出的文件名，默认值为<code>./dist</code>）</li><li>loader:将 webpack 不能识别的模块转为能够识别的有效模块</li><li>plugins(插件)：在 webpack 整个构建过程中注入扩展逻辑来改变构建结果或做你想要做的事情</li></ol><h2 id="demo-配置"><a href="#demo-配置" class="headerlink" title="demo 配置"></a>demo 配置</h2><p><code>使用 webpack 必须安装 webpack 和 webpack-cli（webpack 使用的是 4.x 的版本）</code><br>在官网很明确的指出 webpack v4.0.0 后的版本是开箱即用。但仍还是高度可配置的。<br>在 src 文件新建一个 index.js 文件【webpack 默认入口，如若放其他目录，需修改配置文件中 entry 的值】。index 文件的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const newArr = [</span><br><span class="line">  ...[1, 2, 3].map(value =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> value * 2;</span><br><span class="line">  &#125;)</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>执行<code>npx webpack --mode=development</code> (未在 package.json 中配置命令,直接使用 npx 代替 npm,在 npm 5.2 之后的版本增加 npx 命令，方便用户能够调用项目内部安装的模块)<br>构建完成后 index 里面的内容变成如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/******/ (&#123;</span><br><span class="line">/*! no static exports found */</span><br><span class="line">(<span class="keyword">function</span>(module, exports) &#123;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"const newArr = [\n  ...[1, 2, 3].map(value =&gt; &#123;\n    return value * 2;\n  &#125;)\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBuZXdBcnIgPSBbXG4gIC4uLlsxLCAyLCAzXS5tYXAodmFsdWUgPT4ge1xuICAgIHJldHVybiB2YWx1ZSAqIDI7XG4gIH0pXG5dO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>index 中的内容并没有如我们所想转化为低版本的代码，这里就需要<code>babel-loader</code><br>安装 babel-loader 以及相关依赖@babel/core、@babel/preset-env @babel/plugin-transform-runtime、@babel/runtime、@babel/runtime-corejs3。<br>新建 webpack.config.js 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">test</span>: /\.jsx?$/,</span><br><span class="line">      use: [<span class="string">'babel-loader'</span>],</span><br><span class="line">      options: &#123;</span><br><span class="line">        presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">        plugins: [</span><br><span class="line">          [</span><br><span class="line">            <span class="string">'@babel/plugin-transform-runtime'</span>,</span><br><span class="line">            &#123;</span><br><span class="line">              corejs: 3</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      exclude: /node_modules/ //排除node_modules文件</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以新建.babelrc 文件，添加配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"corejs"</span>: 3</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，再次执行构建命令，输出内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/map */ \"./node_modules/_@babel_runtime-corejs3@7.9.2@@babel/runtime-corejs3/core-js-stable/instance/map.js\");\n/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_map__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_corejs3_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime-corejs3/helpers/toConsumableArray */ \"./node_modules/_@babel_runtime-corejs3@7.9.2@@babel/runtime-corejs3/helpers/toConsumableArray.js\");\n/* harmony import */ var _babel_runtime_corejs3_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nvar _context;\n\nvar newArr = _babel_runtime_corejs3_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(_babel_runtime_corejs3_core_js_stable_instance_map__WEBPACK_IMPORTED_MODULE_0___default()(_context = [1, 2, 3]).call(_context, function (value) &#123;\n  return value * 2;\n&#125;));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBuZXdBcnIgPSBbXG4gIC4uLlsxLCAyLCAzXS5tYXAodmFsdWUgPT4ge1xuICAgIHJldHVybiB2YWx1ZSAqIDI7XG4gIH0pXG5dO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFFQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n"</span>);</span><br></pre></td></tr></table></figure><p>现在成功构建成低版本的代码。<br>webpack 自身只理解 JavaScript，并不能够有效的识别其他文件，如<code>.css</code>以及图片。<br>这里就需要安装<code>style-loader、css-loader、postcss-loader、less-loader</code>。安装完成后，在 webpack.config.js 中配置，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">   rules: [</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">test</span>: /\.(le|c)ss$/,//</span><br><span class="line">       use: [</span><br><span class="line">         <span class="string">'style-loader'</span>,</span><br><span class="line">         <span class="string">'css-loader'</span>,</span><br><span class="line">         &#123;</span><br><span class="line">           loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">           options: &#123;</span><br><span class="line">             plugins: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">               <span class="built_in">return</span> [</span><br><span class="line">                 require(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                   overrideBrowserslist: [<span class="string">'&gt;0.25%'</span>, <span class="string">'not dead'</span>]</span><br><span class="line">                 &#125;)</span><br><span class="line">               ];</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="string">'less-loader'</span></span><br><span class="line">       ],</span><br><span class="line">       exclude: /node_module/</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>style-loader 动态创建 style 标签将 css 插入到 head 中。<br>css-loader 负责处理 @import 等语句。<br>postcss-loader 和 autoprefixer，自动生成浏览器兼容性前缀。<br>less-loader 负责处理编译 .less 文件,将其转为 css。<br>loader 的执行顺序是从右往左，执行顺序 less-loader-&gt;postcss-loader-&gt;css-loader-&gt;style-loader。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@color: red;</span><br><span class="line">body &#123;</span><br><span class="line">  background-color: @color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建完成后如上样式代码会输出如下<code>background-color: red</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/_css-loader@3.4.2@css-loader/dist/runtime/api.js */ \"./node_modules/_css-loader@3.4.2@css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \"body &#123;\\n  background-color: red;\\n&#125;\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMy40LjJAY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9fcG9zdGNzcy1sb2FkZXJAMy4wLjBAcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuL25vZGVfbW9kdWxlcy9fbGVzcy1sb2FkZXJANS4wLjBAbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zcmMvY3NzL21haW4ubGVzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jc3MvbWFpbi5sZXNzP2VhMTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMy40LjJAY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImJvZHkge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmVkO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/_css-loader@3.4.2@css-loader/dist/cjs.js!./node_modules/_postcss-loader@3.0.0@postcss-loader/src/index.js?!./node_modules/_less-loader@5.0.0@less-loader/dist/cjs.js!./src/css/main.less\n"</span>);</span><br></pre></td></tr></table></figure><p>同样，如果我们在 css 中使用了 image，那 webpack 无法识别怎么处理？那么我们需要安装<code>url-loader</code>，注意<code>url-loader</code>依赖<code>file-loader</code>,安装完 url-loader 和 file-loader 后，继续配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.(png|jpg|gif|jpeg|webp|svg|eot|ttf|woff|woff2)$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              outputPath: <span class="string">'assets'</span>,</span><br><span class="line">              <span class="built_in">limit</span>: 10240,//设置最大10kb，小于10kb的资源会转化为base64，大于10kb的资源则会拷贝到dist文件下</span><br><span class="line">              esModule: <span class="literal">false</span>,</span><br><span class="line">              name: <span class="string">'[name]_[hash:6].[ext]'</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        exclude: /node_module/</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，算是完成了一些基本配置。</p>]]></content>
      
      
      <categories>
          
          <category> 程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>20191030随笔</title>
      <link href="/2019/10/30/20191030%E9%9A%8F%E7%AC%94/"/>
      <url>/2019/10/30/20191030%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>总是想写点什么，但又有一种无从下笔的感觉。<br>昨天又梦到又回去北京工作了。<br>一直都在思考回家是不是一种错误的选择？可是既然已经选择已经走了也没办法回头了吧。<br>或许我后悔的点并不是因为北京，而是一些人再也见不到了吧。<br>一直努力暗示自己没错，走了就走了。<br>记忆从什么时候开始下降了呢？最近格外严重。<br>想不起来以前的事了。<br>五年了，竟然在北京呆了五年，我却只记得刚去北京的事，后面的事一点都想不起来了。<br>曾经，每天夜里躲在被窝偷偷哭，眼泪流干，整晚都不睡觉，或许根本就不想睡。<br>可能眼泪真的流完了吧。<br>现在想哭都哭不出来了。<br>人也变得冷漠无情些了。<br>或许我已喜欢这样的自己了。<br>以后也会继续这样吧。</p>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>不理解的一瞬间</title>
      <link href="/2019/06/08/%E4%B8%8D%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%80%E7%9E%AC%E9%97%B4/"/>
      <url>/2019/06/08/%E4%B8%8D%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%80%E7%9E%AC%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>“人如果不自私，就无法活下去，哪里有软弱，哪里就有谎言。”<br>我不知道别人家的父母是否也如我的父母这般，能轻而易举的说出“不想活了”这样的词来威胁子女而达到自己的目的。<br>命是自己的，为什么总是要用自己的命去威胁自己的孩子呢？<br>难道到现在还不明白孩子从一出生开始就是一个独立的生命体，不应该再被控制了吗？<br>留守儿童长大的我，对父母的感情有多深，我自己都不知道。<br>习惯了一个人面对所有的事，习惯自己做决定。<br>我也不知道如何去爱你们，因为你们不曾教过我。<br>你们给我的只有无止境的争吵和冷暴力。<br>所以当你说出“你不听话我都不想活了”这样的话，真的很反感。<br>直到现在，你们都不知道如何为人父母。<br>只知道把自己的意愿强加给子女，逼迫他们听你们的话。<br>这样的生活到底能维持多久呢？<br>我不奢望你们能理解我，但不要自以为是的了解我。<br>有时候真的很想自私的不去考虑你们的感受，能痛快的把你们说教一番。<br>啊哈哈哈哈哈哈哈。。。</p>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我和卷毛的故事</title>
      <link href="/2019/01/23/%E6%88%91%E5%92%8C%E5%8D%B7%E6%AF%9B%E7%9A%84%E6%95%85%E4%BA%8B/"/>
      <url>/2019/01/23/%E6%88%91%E5%92%8C%E5%8D%B7%E6%AF%9B%E7%9A%84%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>卷毛是我的大学同学。<br>因为他烫了一头卷卷的头发，所以我们都叫他卷毛。<br>他不喜欢别人摸他的头发，而我却总是故意去揉他的头发。<br>“头可断血可流，发型不能乱”。因此卷毛每次都很生气，因为我搞乱了他的发型。<br>刚上大学那会，他坐我后面，老师第一次点名,我听到他的名字在心里笑了好久，总是觉得很奇怪，为什么会叫这个名字呢？一直到现在都没能明白，因为卷毛不肯告诉我真正的原因。<br>我本是个不太主动的人，断不可能主动跟他熟念起来。<br>至于怎么熟悉的，却始终想不起来了，感觉这段记忆不存在一样。<br>或许我们一直都很熟悉。<br>他经常逼我给他带午饭，或许我是自愿的，那时的我心里还是有一丝小期许的。<br>上机课他会让我坐他旁边，我会因为害羞故意错开坐。<br>一直记得他说如果我愿意，他会一直陪我。<br>可能他忘了，我却一直记着。<br>他喜欢玩英雄杀，所以我也开始学着玩，还有另外一个同学。<br>我们三个经常通宵玩游戏，可是他却嫌弃我很菜。<br>我努力让自己变的厉害些。<br>可当我游戏玩的很厉害时，我们都毕业了。我们都不再玩这款游戏了。<br>临近毕业之际，我们经常约着其他同学一起去外面棋牌室通宵打麻将，他一直赢，而我却一直输。<br>后来有个培训机构来学校招生，我报名了，他陪我一起报名。<br>后来我不想去，女人是善变的这句话真没错。<br>我拉着卷毛一起去培训机构要钱。<br>我嘴笨，不知道怎么撒谎。他跟那个负责人谈了很久，总算把我俩的钱要回来了。<br>实习的时候几个同学一起在外面租房子，一起上班。<br>我和卷毛在一个公司，本以为我们会合作的很好，可是他却一直吼我。<br>我们会经常吵架，或者说是他经常吼我，我只是默默承受，偷偷抹眼泪而已。<br>他打我了，他以为我会像以前那样不在乎，可是我却什么都不想说。<br>我在心里默默发誓，打死不跟他来往。<br>他可能知道自己错了，主动让我去他房间拿水果吃。要知道他以前可不会让我们进他房间的。<br>我心软了。我突然原谅他了。所以真那个时候的自己太贱了。<br>毕业后，他留在了武汉。<br>不知道当时我为什么没有留在武汉，如果我也在，可能后来的故事会不一样。<br>可我走了。<br>我说我最讨厌这个地方，打死都不想回来。不知道在当时的卷毛听着会是个什么样的感受。<br>年少轻狂，大家做错了很多事。<br>一开始错过就再也回不去了。<br>或许当时离开是因为想逃避一些事。<br>胆小懦弱的我，不敢主动迈出第一步，所以这个故事就不会有结局了。</p>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nodejs从入门到放弃（三）</title>
      <link href="/2018/12/20/nodejs%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2018/12/20/nodejs%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>如果读过了我的从入门到放弃的第二篇，就会对Node的异步I/O有所了解，接下来我要说的是Node中还存在一些与异步I/O无关的异步API。</p><hr><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p><code>setInterval()</code>和<code>setTimeout()</code>与浏览器中的API是一致的，分别用于单次和多次定时执行任务。他们实现的原理与异步I/O毕竟类似，只是没有线程池的参与。<br>调用<code>setInterval()</code>huo3<code>setTimeout()</code>创建的定时器会被插入到定时器观察者内部的红黑树中，每次Tick执行，就会从红黑树中取出定时器对象，检查是否超过定时时间，如果超过，则形成一个事件，回调函数立即执行。看图：<br><img src="./定时器.png" alt="定时器"></p><h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h2><p>由于事件循环的特点，定时器的精确度是不够的，比如某个任务耗时许久，下个任务原本已经到了执行事件却因为这个耗时任务而不能立即执行。再加上定时器是动用红黑树，创建定时器对象和迭代等操作，毕竟浪费性能。相对而言，<code>process.nextTick()</code>的操作相对较为轻量，每次调用<code>process.nextTick()</code>都是将回调函数放入队列，下一轮tick取出执行。</p><h2 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h2><p><code>setImmediate()</code>也是将回调函数延迟执行，在Nodev0.9.1之前，<code>setImmediate()</code>还没实现呢，是通过<code>process.nextTick()</code>来完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(function()&#123;</span><br><span class="line">    console.log(&quot;延迟执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;正常输出&quot;);</span><br><span class="line">//result</span><br><span class="line">正常输出</span><br><span class="line">延迟执行</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function()&#123;</span><br><span class="line">    console.log(&quot;延迟执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;正常输出&quot;);</span><br><span class="line">//result</span><br><span class="line">正常输出</span><br><span class="line">延迟执行</span><br></pre></td></tr></table></figure><p>从以上两段代码看，结果一样，但实际它们还是有区别的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function()&#123;</span><br><span class="line">    console.log(&quot;setImmediate延迟执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(function()&#123;</span><br><span class="line">    console.log(&quot;nextTick延迟执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;正常输出&quot;);</span><br><span class="line">//result</span><br><span class="line">正常输出</span><br><span class="line">nextTick延迟执行</span><br><span class="line">setImmediate延迟执行</span><br></pre></td></tr></table></figure></p><p>从结果可以看出<code>process.nextTick()</code>的优先级高于<code>setImmediate()</code>，是因为<em>事件循环对观察者的检查是有先后顺序的</em>（ps:继续往下看会详细写这块内容。）<br><code>process.nextTick()</code>的回调函数是存在一个数组，<code>setImmediate()</code>的结果是保存在链表中。<br>在行为上，<code>process.nextTick()</code>在每轮循环会将数组中的回调函数全部执行完，<code>setImmediate()</code>在每轮循环中执行链表中的一个回调函数。用一段代码来证明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(function()&#123;</span><br><span class="line">    console.log(&quot;next tick....1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.nextTick(function()&#123;</span><br><span class="line">    console.log(&quot;next tick....2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setImmediate(function()&#123;</span><br><span class="line">    console.log(&quot;immediate.....1&quot;);</span><br><span class="line">    process.nextTick(function()&#123;</span><br><span class="line">        console.log(&quot;next tick....3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(function()&#123;</span><br><span class="line">    console.log(&quot;immediate.....2&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">//result</span><br><span class="line">next tick....1</span><br><span class="line">next tick....2</span><br><span class="line">immediate.....1</span><br><span class="line">next tick....3</span><br><span class="line">immediate.....2</span><br></pre></td></tr></table></figure></p><p>从结果可以看出第一个<code>setImmediate()</code>的回调函数执行后，并没有立即执行第二个，而是进入下一轮循环，再次优先调用<code>process.nextTick()</code>。<br>以上便是在Node中的几种不涉及异步I/O的异步API。但这几种API具体在事件循环中又是一个什么执行顺序？继续往下看，please。<br>先来一段分割线。。。</p><hr><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>当Node启动时，便会初始化event loop，每一个event loop都包含六个循环阶段。看下图：<br><img src="./event loop循环阶段.png" alt="event loop循环阶段"></p><ul><li><em>timers阶段</em>：在这个阶段执行定时器预定的callback，比如<code>setTimeout(callback)</code>和<code>setInterval(callback)</code>。</li><li><em>I/O callbacks阶段</em>：除其他阶段以外的callback。</li><li><em>idle，prepare阶段</em>：仅node内部使用。</li><li><em>poll阶段</em>：获取新的I/O事件，适当条件下阻塞。</li><li><em>check阶段</em>：执行<code>setImmediate()</code>设定的callback。</li><li><em>close callback阶段</em>：close的callback。<br>每一个阶段都有各自相对应的队列，当event loop运行到指定阶段，node将从对应的队列取出callback执行，当队列中的callback执行完或者超过该阶段的上限，event loop会转入下一个阶段。<br><strong><em>注意:<code>process.nextTick()</code>不在上面任何一个阶段。</em></strong><h3 id="setTimeout-and-setImmediate"><a href="#setTimeout-and-setImmediate" class="headerlink" title="setTimeout and setImmediate"></a>setTimeout and setImmediate</h3><code>setTimeout</code>在poll阶段空闲，且设定事件到达后执行，在timer阶段执行。<br><code>setImmediate</code>在poll阶段完成后进入check执行。<br>二者调用顺序取决event loop上下文，在异步I/O callback之外调用，执行顺序不确定。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;setTimeout finished...&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(function()&#123;</span><br><span class="line">    console.log(&quot;setImmediate finished...&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">//result</span><br><span class="line">setTimeout finished...</span><br><span class="line">setImmediate finished...</span><br><span class="line">也可能出现</span><br><span class="line">setImmediate finished...</span><br><span class="line">setTimeout finished...</span><br></pre></td></tr></table></figure></li></ul><p>在异步I/O callback中的调用顺序一定是先执行<code>setImmediate</code>后执行<code>setTimeout</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&quot;./main/read.txt&quot;, () =&gt; &#123;</span><br><span class="line">    //约5ms读取完毕</span><br><span class="line">    console.log(&quot;read file finished...&quot;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;setTimeout finished...&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    setImmediate(function () &#123;</span><br><span class="line">        console.log(&quot;setImmediate finished...&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">//result</span><br><span class="line">read file finished...</span><br><span class="line">setImmediate finished...</span><br><span class="line">setTimeout finished...</span><br></pre></td></tr></table></figure></p><p>是因为异步I/O callback是在poll阶段执行，执行完毕后进入到check阶段执行<code>setImmediate</code>，后进入到timer阶段执行<code>setTimeout</code>。</p><h3 id="Poll阶段"><a href="#Poll阶段" class="headerlink" title="Poll阶段"></a>Poll阶段</h3><p>poll阶段是整个event loop比较重要的阶段。<br>在node.js中，任何异步方法（除timer，closer，setImmediate）完成时，都会将其callback加到poll queue，并立即执行。<br>当event loop进入poll阶段，分两种情况：</p><ol><li><em>有timer</em>：在有timer的情况下，如果poll的队列中没有任何待处理的事件，就会检查timer队列中有没有已经到了时间需要执行的事件，如果至少有一个，那么event loop将按照循环顺序进入timer阶段执行timer队列。</li><li><em>没有timer</em>：在没有timer的情况下，如果poll队列中有待处理的事件，则依次执行，直到队列为空，或者执行的callback到达系统上限。当poll队列为空，则会判断是否有<code>setImmediate()</code>设置的callback，如果存在则结束poll阶段，马上进入check阶段执行check队列中的事件；如果没有<code>setImmediate()</code>设置的callback，则event loop会阻塞在poll阶段，死等，直到有callback加入队列。<br>看下面两段代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&quot;./main/read.txt&quot;,()=&gt;&#123;</span><br><span class="line">    //约5ms读取完毕</span><br><span class="line">    console.log(&quot;read file finished...&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;setTimeout finished...&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(function()&#123;</span><br><span class="line">    console.log(&quot;setImmediate finished...&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">//result</span><br><span class="line">setTimeout finished...</span><br><span class="line">setImmediate finished...</span><br><span class="line">read file finished...</span><br></pre></td></tr></table></figure></li></ol><p>在执行到poll阶段的时候，已经有设置过的timer，而且此时poll阶段的队列为空，而timer的队列中已经有待执行的callback，则马上结束poll阶段按顺序执行进入到timer阶段，这里有<code>setTimeout(callback)</code>和<code>setImmediate(callback)</code>的回调顺序取决event loop上下文确定，也就是说它俩的执行先后顺序不确定。多执行几次说不定会出现先执行<code>setImmediate(callback)</code>的回调事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&quot;./main/read.txt&quot;,()=&gt;&#123;</span><br><span class="line">    //约5ms读取完毕</span><br><span class="line">    console.log(&quot;read file finished...&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;setTimeout finished...&quot;);</span><br><span class="line">&#125;,6);</span><br><span class="line">setImmediate(function()&#123;</span><br><span class="line">    console.log(&quot;setImmediate finished...&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">//result</span><br><span class="line">setImmediate finished...</span><br><span class="line">read file finished...</span><br><span class="line">setTimeout finished...</span><br></pre></td></tr></table></figure></p><p>在执行到poll阶段的时候，此时文件还未读取完毕，所以poll阶段的队列为空，虽然已经有设置过的timer，时间未到，timer队列中没有待处理的事件，此时有<code>setImmediate(callback)</code>设置的回调，则马上结束poll阶段进入check阶段执行callback，该轮event loop结束后进入到下一次tick，timer队列依旧为空，进入到poll阶段，此时文件读取完毕，回调函数被当作事件进入到poll队列，执行该事件后，timer中的callback已经到时间执行，则马上按顺序进入到timer阶段执行队列中的事件。</p><h3 id="process-nextTick-1"><a href="#process-nextTick-1" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h3><p>之前提到<code>process.nextTick()</code>不属于任何一个阶段，那它什么时候执行？<br><code>process.nextTick()</code>是在各个阶段切换的中间执行，也就是说是从一个阶段切换到下一个阶段这个间隙执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&quot;./main/read.txt&quot;,()=&gt;&#123;</span><br><span class="line">    //约5ms读取完毕</span><br><span class="line">    console.log(&quot;read file finished...&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;setTimeout finished...&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(function()&#123;</span><br><span class="line">    console.log(&quot;setImmediate finished...&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(function()&#123;</span><br><span class="line">    console.log(&quot;next tick....1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.nextTick(function()&#123;</span><br><span class="line">    console.log(&quot;next tick....2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//result</span><br><span class="line">next tick....1</span><br><span class="line">next tick....2</span><br><span class="line">setTimeout finished...</span><br><span class="line">setImmediate finished...</span><br><span class="line">read file finished...</span><br></pre></td></tr></table></figure></p><p>上面代码中从timer阶段进入下个阶段间隙执行<code>process.nextTick()</code>，上面提到过<code>process.nextTick()</code>的回调函数是保存在数组中，一次性取出全部执行。<br><code>process.nextTick()</code>是早起Node版本无<code>setImmediate()</code>时的产物，node作者推荐尽量使用<code>setImmediate()</code>。<br>这是为啥子呢？<br>试想，如果我们在一个递归中无限循环调用<code>process.nextTick()</code>，那是不是其他阶段的callback则没有机会执行了呢？<br>而<code>setImmediate()</code>就不一样，只在check阶段，而且每次从队列中只取出一个事件执行，那这样大家都有机会执行了，能分到一杯羹。。ps:啊哈哈哈,不知道为啥此刻脑子想到某个港剧中几个大佬抢地盘的场景。<br>以上所有便是Node中事件循环的整个过程。</p><hr><p>ps:参考朴灵的《深入浅出》和 <a href="https://cnodejs.org/topic/57d68794cb6f605d360105bf" target="_blank" rel="noopener">https://cnodejs.org/topic/57d68794cb6f605d360105bf</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nodejs从入门到放弃（二）</title>
      <link href="/2018/12/18/nodejs%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/12/18/nodejs%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在Node中异步I/O是何等份量大伙多多少少应该知道点，没吃过猪肉难道还没见过猪跑么？<br>Node虽然是单线程，但这里的单线程仅仅只是Javascript执行在单线程中罢了。<br>在Node中无论是何种平台，内部完成I/O任务的另有线程池。如下图所示：<br><img src="./基于libuv的架构.png" alt="基于libuv的架构"></p><hr><p><em>那Node是如何实现异步I/O的呢？</em><br>我们先看看其他内容，转移下注意力。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>在进程启动时，Node会创建一个类似<code>while(true)</code>的循环，每次循环的过程我们称之为Tick。这个过程是为了检查是否有事件待处理，如果有则取出事件及相关的回调函数并执行，然后再进入下一个循环直到没有需要处理的事件则退出进程。如下图所示：<br><img src="./Tick流程图.png" alt="Tick流程图"></p><h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>在每个Tick的过程中，如何判断是否有待处理的事件呢？那么就需要观察者登场啦。🎉🎉🎉<br>在每个事件循环中都会有一个或者多个观察者，判断是否待处理的事件就是向观察者询问是否有要处理的事件。就像咱们下馆子一样，馆子的厨房一遍一遍的做菜，厨房就是事件循环。那么他们做什么样的菜就需要询问服务员，服务员会告诉厨房有没有要做的菜，这里服务员便是观察者。具体做什么样的菜，就是咱们这些下馆子的人来决定的。</p><h2 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h2><p>一般，非异步回调函数是有我们自行调用。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function processEvt(list, callback) &#123;</span><br><span class="line">    for (var i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">        callback(list[i], i, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但对于Node的异步I/O调用而言，回调函数却不是我们开发者来调用，那么我们发出调用到回调函数被执行，这中间发生了什么呢？<br>事实上，从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，这就是<em>请求对象</em>。<br>下面以<code>fs.open()</code> 举例，探索Node与底层之间如如何执行异步I/O调用以及回调函数是如何被调用执行的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.open(&apos;./files/test.txt&apos;,&apos;a&apos;,(err,fd)=&gt;&#123;</span><br><span class="line">    //各种操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>那<code>fs.open()</code>方法内部是什么样呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.open = function (path, flags, mode, callback) &#123;</span><br><span class="line">    //......</span><br><span class="line">    binding.open(pathModule._makeLong(path), stringToFlags(flags), mode, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这两段代码中不难看出来JavaScript层面的代码通过node核心模块，核心模块调用C++内建模块，内建模块又会做什么呢？看下图：<br><img src="./调用示意图.png" alt="调用示意图"><br>内建模块会通过libuv进入系统调用，这也是Node里最经典的调用方式。<br>将libuv作为封装层，有两个平台的实现，实质上都是调用了<code>uv_fs_open()</code>方法，在<code>uv_fs_open()</code>的调用过程中，我们创建一个<em>FSReqWrap</em>请求对象，会把从JavaScript传入的参数和当前方法都封装在这个请求对象中，注意：回调函数会被设置在这个请求对象的oncomplete_sym属性上。<br>请求对象包装完毕后，在windows下，调用<code>QueueUserWorkItem()</code>方法将FSReqWrap这个请求对象推入到线程池中等待执行。<br><code>QueueUserWorkItem()</code>方法接受三个参数，第一个参数是将要执行的方法的引用，第二个参数是方法运行时所需要的参数，第三个参数是执行的标识。<br>当线程池中有可用线程时，我们会调用传入的方法，根据参数调用底层相应的函数。<br>至此，JavaScript调用就可以返回了，由JavaScript层面发起的异步调用第一阶段就结束了。JavaScript线程可以继续执行当前任务的后续操作，当前的I/O操作在线程池中等待执行，不管它是否阻塞I/O，都不会影响JavaScript线程的后续执行，如此便达到了异步的目的。<br><em>请求对象</em>是异步I/O过程中最重要的中间产物，因为所有状态都保存在这个对象中，包括送入线程池等待执行以及操作完毕后的回调处理。</p><h2 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h2><p>线程池中的I/O操作调用完毕后会将结果储存在某个属性上，通过调用<code>PostQueuedCompletionStatus()</code>通知IOCP，告知当前对象操作已经完成，并将线程归还线程池。<br>我们通过<code>GetQueuedCompletionStatus()</code>提取。<br>在这个过程之，我们会调用事件循环的I/O观察者，在每次Tick的执行中，它会调用<code>GetQueuedCompletionStatus()</code>方法检查线程中是否有执行完的请求，如果存在，则会把请求对象加入的I/O观察队列中，将其当作事件处理。I/O观察者回调函数的行为就是取出请求对象的结果属性作为参数，取出oncomplete_sym属性作为方法并执行。</p><hr><p>以上便是整个异步I/O的流程，看图：<br><img src="./异步IO的流程.png" alt="异步IO的流程"><br>那么读到这里，有没有醍醐灌顶？原来这就是Node中异步I/O的整个过程。<br>回到Node是如何实现异步I/O的问题，聪明如我的小伙伴们应该知道答案了吧。<br>事件循环、观察者、请求对象、I/O线程池共同构成了Node异步的基本要素。</p><hr><p>ps:参考朴灵的《深入浅出》</p>]]></content>
      
      
      <categories>
          
          <category> 程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>白夜行</title>
      <link href="/2018/12/13/%E7%99%BD%E5%A4%9C%E8%A1%8C/"/>
      <url>/2018/12/13/%E7%99%BD%E5%A4%9C%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 书迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 东野圭吾 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解Symbol类型</title>
      <link href="/2018/12/10/%E7%90%86%E8%A7%A3Symbol%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/12/10/%E7%90%86%E8%A7%A3Symbol%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Symbol是es6新增的原始数据类型，表示独一无二的值。<br>Symbol是通过Symbol()函数生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s=Symbol();</span><br><span class="line">typeof s //&quot;symbol&quot;</span><br></pre></td></tr></table></figure></p><p>变量s是一个独一无二的值，是Symbol数据类型。<br>【未完待续】</p>]]></content>
      
      
      <categories>
          
          <category> 程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>隔壁家的小胖子</title>
      <link href="/2018/12/07/%E9%9A%94%E5%A3%81%E5%AE%B6%E7%9A%84%E5%B0%8F%E8%83%96%E5%AD%90/"/>
      <url>/2018/12/07/%E9%9A%94%E5%A3%81%E5%AE%B6%E7%9A%84%E5%B0%8F%E8%83%96%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>前天晚上照常和我妈打电话，她说隔壁家的小胖子终于出现了。<br>隔壁家的小胖子是我们从小玩到大的小伙伴，准确点说是和我弟弟从小玩到大。和我么，只是小时候一起玩过。<br>小时候在三哥的带领下，我们会一起欺负小胖子，小胖子真的很胖，胖到他的裤裆总是隔三岔五的撕破。小胖子却怪裤子质量不结实，他奶奶给他缝好好他会再次撕破，他会怪奶奶买的针线质量差。<br>最后一次见他是2014年过年，我弟弟带他来我们家睡觉，他说爹妈又去赌博场了，他一个人在家害怕。<br>我爸特别喜欢逗他，总是说要给他介绍外地媳妇。<br>每次我爸说这事的时候他都会问“这次又是哪里的姑娘？”。<br>小胖子可以在前一秒和你说话，下一秒就顺利进入梦乡还带着打呼噜声，任你怎么叫都叫不醒。<br>吃的特多，还总嚷嚷着要减肥。又特别爱睡觉。<br>小胖子是家里的独生子，和我弟弟年龄一样大，又是隔壁，从小一起长大，所以小胖子和我弟弟关系特别好。<br>至于他爹妈为什么不给他生个弟弟妹妹的，我猜可能是要留着钱赌博吧。<br>后来小胖子消失了，准确的说他全家都消失了，没有任何消息。他们家被人泼的红油漆，门口写的“欠债还钱，天经地义”，家里的窗户也被砸破了。<br>听说是因为父母赌博欠下高利贷，还不起了。只能玩失踪。不再现身。<br>就这样，小胖子跟着父母逃亡了几年。我不知道是不是真的逃亡，可能是躲在某个地方偷摸的生活着呢。<br>他现在出现了，联系我弟弟，他说“这些年不管怎么换手机怎么删联系人，永远留着我弟弟的手机号”。幸运的是我弟弟他也一直不换号码。所以小胖子能再次联系上我弟弟。<br>小胖子说这些年的日子已经足够他想清楚了，不管怎么埋怨父母，怎么怨恨都改不了任何事实。他只能接受。<br>现在能做的就是慢慢打工，攒点钱，让以后的日子好过一些。<br>我妈说小胖子瘦了，不再似以前那么肥嘟嘟的。<br>我想经历这些事人都会变的。<br>没有人会一直生活在天真无邪的年纪，有这样的人是因为他还没经历到能让他改变的事。<br>真希望小胖子以后的生活能越过越好，摊上这样的父母你真没办法。唯一能做的是让自己越来越好。</p>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nodejs从入门到放弃（一）</title>
      <link href="/2018/11/15/nodejs%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/11/15/nodejs%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>年初就买了一本《深入浅出node.js》，一直拖到现在才看，为自己的拖延症汗颜。<br>不为自己懒惰找借口。</p><hr><h2 id="CommonJs的规范"><a href="#CommonJs的规范" class="headerlink" title="CommonJs的规范"></a>CommonJs的规范</h2><ol><li>通过require引用模块</li><li>模块定义：一个文件就是一个模块</li><li>模块标识：传递给require方法的参数名必须是小驼峰命名的字符串或相对路径、绝对路径。</li></ol><hr><h2 id="NodeJs如何实现CommonJs规范"><a href="#NodeJs如何实现CommonJs规范" class="headerlink" title="NodeJs如何实现CommonJs规范?"></a>NodeJs如何实现CommonJs规范?</h2><p>先看下面这段代码，有没有考虑过为什么直接可以调用require方法？为什么只有通过exports属性导出方法？module是什么？module和exports是什么关系？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var fs=require(&apos;fs&apos;);</span><br><span class="line">// console.log(module.paths);</span><br><span class="line">//模块定义</span><br><span class="line">function read()&#123;</span><br><span class="line">    fs.readFile(&apos;readme.md&apos;,function(err,file)&#123;</span><br><span class="line">        console.log(&apos;read finished...&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(&apos;read start...&apos;);</span><br><span class="line">&#125;</span><br><span class="line">function write()&#123;</span><br><span class="line">    console.log(&quot;write&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports.readFiles=read;</span><br><span class="line">module.exports.writeFiles=write;</span><br></pre></td></tr></table></figure></p><p>实际上，在编译过程中，Node对获取的js文件内容会有一个封装，怎么封装？就是在内容头部加<code>(function(require,exports,module,__dirname,__filename){/n</code>,尾部会加上<code>})/n</code>。也就是说我们能用的require,exports,module,<strong>dirname,</strong>filename都是通过参数传递进来的。封装后，每个模块都有了隔离的作用域。<br>包装之后的代码通过原生模块vm的runInThisContext()方法得到一个具体的function对象，把当前文件的exports,module,require，路径以及完整路径传递给这个function，返回exports以及挂在这个属性的方法和属性。所以我们只能访问到exports上的属性和方法，其余未挂在这个对象上的则不能访问。<br>看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Module(id, parent) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.exports = &#123;&#125;;</span><br><span class="line">    this.parent = parent;</span><br><span class="line">    if (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">        parent.children.push(this)</span><br><span class="line">    &#125;</span><br><span class="line">    this.filename = null;</span><br><span class="line">    this.loaded = false;</span><br><span class="line">    this.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Node中每个文件都是一个对象。Module就是模块本身。从上面代码不难看出exports是module的属性，这意味着我们可以用<code>module.exports.readFiles=read;</code>或者<code>exports.readFiles=read;</code>的方式导出方法或属性。<br>可能又会有好奇宝宝问为什么用<code>exports.readFiles=read</code>的方式，而不是<code>exports=read</code>的方式？因为exports是作为形参传入，直接赋值形参是不会改变方法以外的exports的内容。来，看看下面这段代码有木有些许明白了呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a=10;</span><br><span class="line">function change(a)&#123;</span><br><span class="line">    a=20;</span><br><span class="line">&#125;</span><br><span class="line">change(a);</span><br><span class="line">console.log(a) //10</span><br></pre></td></tr></table></figure></p><p>以上奏是NodeJs对CommonJs规范的实现。</p><hr><p>ps:参考朴灵的《深入浅出》</p>]]></content>
      
      
      <categories>
          
          <category> 程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于JavaScript类型转化</title>
      <link href="/2018/11/13/%E5%85%B3%E4%BA%8EJavaScript%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/"/>
      <url>/2018/11/13/%E5%85%B3%E4%BA%8EJavaScript%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>JavaScript类型转化分隐式转化和显式转化。<br>在JavaScript中类型转化只能转化为三种基本类型：   </p><ol><li>to string</li><li>to number</li><li>to boolean</li></ol><hr><h2 id="to-string"><a href="#to-string" class="headerlink" title="to string"></a>to string</h2><p>所有调用String显式转化为string类型的都可以得到你想要的结果。<br>当遇到操作符+号，其中一个操作数为string类型，另一个操作数则会隐式转化为string类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String(1) //显式转换 &apos;1&apos;</span><br><span class="line">String(1.2) //显式转换 &apos;1.2&apos;</span><br><span class="line">String(null) //显式转换 &apos;null&apos;   </span><br><span class="line">String(undefined) //显式转换 &apos;undefined&apos;  </span><br><span class="line">String(true) //显式转换 &apos;true&apos;</span><br><span class="line">String(false) //显式转换 &apos;false&apos;</span><br><span class="line">1+&apos;&apos; //隐式转换  操作符+号 且其中一个操作数为string类型。结果&apos;1&apos;</span><br></pre></td></tr></table></figure></p><h2 id="to-number"><a href="#to-number" class="headerlink" title="to number"></a>to number</h2><p>调用Number显式转化为number类型。<br>隐式转化的情况有以下几种：</p><ul><li>比较操作符（&lt;,&gt;,&lt;=,&gt;=）</li><li>按位操作符（| &amp; ^ ~）</li><li>四则运算 （- + * / %） 其中操作符为+号，一方操作数为string类型，则不会隐式转化为number类型。</li><li>一元操作符 （+） </li><li>loose equality operator == ，也包括!= （不知道loose equality应该翻译成啥样的词。大意就是判断是否相等，只比较值，不考虑type是否相等。）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Number(&apos;&apos;) // 0</span><br><span class="line">Number(null) //  0</span><br><span class="line">Number(undefined) // NaN   </span><br><span class="line">Number(&apos;12&apos;) // 12   </span><br><span class="line">Number(&apos;12s&apos;) // NaN  </span><br><span class="line">Number(true) // 1</span><br><span class="line">Number(false) // 0</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：虽然<code>Number(null)</code>为0，但<code>null==0</code>为false，<code>null==undefined</code>为true。NaN不等于任何值，包括它自己</strong></p><h2 id="to-boolean"><a href="#to-boolean" class="headerlink" title="to boolean"></a>to boolean</h2><p>调用Boolean显示转化为boolean，或者遇到逻辑操作符(|| &amp;&amp; !) 则会隐式转化为boolean类型。<br>除了以下几种情况转为false，其他则为true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Boolean(&apos;&apos;)  // false </span><br><span class="line">Boolean(0)  // false </span><br><span class="line">Boolean(-0)  // false </span><br><span class="line">Boolean(null) // false</span><br><span class="line">Boolean(undefined) // false</span><br><span class="line">Boolean(NaN) // false    </span><br><span class="line">Boolean(false) // false</span><br></pre></td></tr></table></figure></p><p>即使是[]或者{}对象，也会转化为true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Boolean(&#123;&#125;)             // true</span><br><span class="line">Boolean([])             // true</span><br><span class="line">Boolean(function() &#123;&#125;)  // true</span><br></pre></td></tr></table></figure></p><p>以上为基本类型显式或隐式转化。</p><hr><h2 id="Object-convert-to-Number-or-String"><a href="#Object-convert-to-Number-or-String" class="headerlink" title="Object convert to Number or String"></a>Object convert to Number or String</h2><p>Object 依然只能转化为number、string和boolean 三种基本类型。</p><ul><li>Object转化为boolean最简单，永远为true.即使为空对象或者空数组等。</li><li>Object转化为stirng或者number，通过调用一个内置方法<code>[[ToPrimitive]]</code>实现转化。代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function ToPrimitive(input, preferredType)&#123;</span><br><span class="line">  </span><br><span class="line">  switch (preferredType)&#123;</span><br><span class="line">    case Number:</span><br><span class="line">      return toNumber(input);</span><br><span class="line">      break;</span><br><span class="line">    case String:</span><br><span class="line">      return toString(input);</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      return toNumber(input);  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function isPrimitive(value)&#123;</span><br><span class="line">    return value !== Object(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function toString()&#123;</span><br><span class="line">    if (isPrimitive(input.toString())) return input.toString();</span><br><span class="line">    if (isPrimitive(input.valueOf())) return input.valueOf();</span><br><span class="line">    throw new TypeError();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function toNumber()&#123;</span><br><span class="line">    if (isPrimitive(input.valueOf())) return input.valueOf();</span><br><span class="line">    if (isPrimitive(input.toString())) return input.toString();</span><br><span class="line">    throw new TypeError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>一般来说，转化的过程如下：</p><ol><li>input为基本类型，啥也不做直接return。</li><li>调用input.toString(),结果为基本类型，return。</li><li>调用input.valueOf()，结果为基本类型，return。</li><li>不满足以上三点则抛出TypeError.<br>转化为number，则先调用valueOf(),再调用toString();转化为string，则正好相反，先toString(),再valueOf()。<br>不同操作符会触发不同转化规则，根据参数preferredType要么转化为number要么是string。<br><strong>注意：遇到==和+操作符，preferredType未赋值或者等于默认值时，则默认转为number，除了Date。</strong>   </li></ol><pre><code>var obj = {  prop: 101,  toString(){    return &apos;Prop: &apos; + this.prop;  },  valueOf() {    return this.prop;  }};console.log(String(obj));  // &apos;Prop: 101&apos;console.log(obj + &apos;&apos;)      // &apos;101&apos;console.log(+obj);         //  101console.log(obj &gt; 100);    //  true/** Date测试 */let d=new Date();let str=d.toString();let num=d.valueOf();console.log(d==str) //trueconsole.log(d==num) //false</code></pre><hr><p>参考链接：<a href="https://medium.freecodecamp.org/js-type-coercion-explained-27ba3d9a2839" target="_blank" rel="noopener">https://medium.freecodecamp.org/js-type-coercion-explained-27ba3d9a2839</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生命</title>
      <link href="/2018/10/29/%E7%94%9F%E5%91%BD/"/>
      <url>/2018/10/29/%E7%94%9F%E5%91%BD/</url>
      
        <content type="html"><![CDATA[<p>弟弟突然打电话让我帮忙给他朋友买张回家的票。<br>我认识这个99年出生的姑娘，一直打趣说是弟弟的女朋友。因为她也说过要嫁给我弟弟的话。<br>许多年以后她会不会觉得自己年少无知竟然说出这么荒唐的话呢？<br>姑娘家里还有个正在读初中的妹妹，不知道什么原因跳楼了。显然，“不死也废”这话不是没有道理的，她妹妹下巴缝了三十多针，脊椎骨断了，此生断不可能再站起来了，这一生算是废了。正值花季，却干了这么荒唐的事，不知道醒来后的妹妹会不会后悔？会不会在夜深人静的时候痛苦不已？想必会的。<br>我想不出来以后她们一家该怎么过？我没法想。姑娘的一生毁了，父亲也摔断了腿，家里全靠母亲以及自己打工挣钱，昂贵的医药费必然让她们望而却步。<br>我真的难受，真的心疼。<br>我不知道到底是在心疼别人还是心疼我自己？我自己的父亲也摔了，是他自己任性妄为造成的。他必然是后悔的，因为我见他流泪了。他哭了，他想不明白怎么会变成这样？我想在梦里他一定会想回到以前，那个活蹦乱跳的自己。当然，那是不可能了。因为我也经常在梦里梦到那个活蹦乱跳的父亲。用活蹦乱跳形容自己的父亲或许不合适，但他就是这样的一个小孩子。<br>再也回不去了。<br>身体每一个受伤的部分都会留下疤痕的。父亲身体里埋了三个管，这三根管会永远陪着他，脑袋缺失的那块头骨也永远不会再回来了。<br>每当想到这些，真的灰常心疼难受。<br>我一直以为自己是一个狠心的人，或许我一直试图做一个狠心的人，却没办法对周遭这一切置之不顾。<br>生命真的很脆弱，稍不留神就溜走了。</p>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小小小小的火</title>
      <link href="/2018/10/16/%E5%B0%8F%E5%B0%8F%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%81%AB/"/>
      <url>/2018/10/16/%E5%B0%8F%E5%B0%8F%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%81%AB/</url>
      
        <content type="html"><![CDATA[<p>“永远记得，你呼吸着的每一个瞬间，都应该去过你真正想要的生活。”<br>我现在的生活是我真正想要的么？无数次问过我自己，终究没有得到答案。<br>我想其实我自己也不知道。<br>伊奇一把火烧了房子，在父母兄弟姐妹眼里，她就是一个疯子。<br>米娅是理查德森家的房客，带着女儿珀尔一起住进了从理查德森家租来的房子。<br>米娅声称自己是一名艺术工作者，只不过偶尔为了生活需要去超市、餐馆等地方做兼职。<br>每在一个地方完成一副艺术作品，立马带着女儿搬家去到一个新地方。寻找灵感，继续艺术工作。<br>在这样的环境下，珀尔多么渴望拥有一个属于自己的房间，可以永远的住下去。珀尔不敢交朋友，不敢对一个地方产生感情，因为她知道过不了多久，母亲完成作品就会带着她离开。<br>当母亲告诉她，她们可以永远住在从理查德森家租的房子里，不用再搬家了。<br>终于可以在一个地方长久的住着，是一件多么令人开心的事情，珀尔想着。</p>]]></content>
      
      
      <categories>
          
          <category> 书迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伍绮诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的slider组件</title>
      <link href="/2018/10/10/%E6%88%91%E7%9A%84slider%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/10/10/%E6%88%91%E7%9A%84slider%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>断断续续写了差不多两周，终于搞定了。<br>写的比较简单，先看效果图。<br><img src="./slider效果图.gif" alt="slider"><br>开始我想的太简单了，总认为用jquery的slider就可以搞定。<br>实际上自己写的一套完整组件怎么能用jquery呢？<br>尝试用原生JavaScript搞定。<br>整个组件分为三块：灰色背景条、左侧绿色背景条以及拖拽的结点。<br>在拖拽的结点上绑定mousedown事件，再拖拽的时候全局注册mouseto事件，mouseup的时候移除全局注册的事件。部分代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mousedown: function(event) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">      this.onDragStart(event);</span><br><span class="line">      window.addEventListener("mousemove", this.onDraging);</span><br><span class="line">      window.addEventListener("mouseup", this.onDragEnd);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p><p>在拖拽的过程中要随时计算当前的位置。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">onDraging: function(event) &#123;</span><br><span class="line">      if (this.draging) &#123;</span><br><span class="line">        let clientX = event.clientX;</span><br><span class="line">        //compute the diff of draging.</span><br><span class="line">        let diff = ((clientX - this.startX) / this.sliderSize) * 100;</span><br><span class="line">        this.resetSliderSize();</span><br><span class="line">        this.newPosition = this.startPosition + diff;</span><br><span class="line">        this.setPosition(this.newPosition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最关键的点是如何计算当前的位置，首先拖拽到的新位置一定是在[0-100]范围，一定要排除其他乱七八糟的位置。<br>我们把结点当作一个人，拖拽就是走路。<br>先计算出我们每走一步有多长，得出lengthPerSteps。<br>我们已经走了多长的路也就是对应newposition，通过newPostion / lengthPerSteps计算出我们走了多少步。<br>（走的步数*每一步的长度*单位值+最小值）的出来的value是对应的slider的value。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setPosition: function(newPostion) &#123;</span><br><span class="line">      if (newPostion <span class="tag">&lt; <span class="attr">0</span>) &#123;</span></span><br><span class="line"><span class="tag">        <span class="attr">newPostion</span> = <span class="string">0;</span></span></span><br><span class="line"><span class="tag">      &#125; <span class="attr">else</span> <span class="attr">if</span> (<span class="attr">newPostion</span> &gt;</span> 100) &#123;</span><br><span class="line">        newPostion = 100;</span><br><span class="line">      &#125;</span><br><span class="line">      //compute the length of one step.</span><br><span class="line">      let lengthPerSteps = 100 / ((this.max - this.min) / this.steps);</span><br><span class="line">      //the counts of step</span><br><span class="line">      let steps = newPostion / lengthPerSteps;</span><br><span class="line">      //get value,means current position</span><br><span class="line">      let value =</span><br><span class="line">        steps * lengthPerSteps * (this.max - this.min) * 0.01 + this.min;</span><br><span class="line">      this.value = value.toFixed(0);</span><br><span class="line">      this.oldValue = value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>拖拽完成后移除全局注册的事件。<br>完整代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"m-slider"</span> <span class="attr">ref</span>=<span class="string">"slider"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"m-slider__left"</span> <span class="attr">:style</span>=<span class="string">"barStyle"</span> @<span class="attr">click</span>=<span class="string">"onClickJump"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"m-slider__background"</span> @<span class="attr">click</span>=<span class="string">"onClickJump"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"m-slider__wrapper"</span> @<span class="attr">mousedown</span>=<span class="string">"mousedown"</span>  <span class="attr">:style</span>=<span class="string">"&#123;left:currentPosition&#125;"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"m-slider__wrapper--point"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">import "./Slider.css";</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">export default &#123;</span></span><br><span class="line"><span class="undefined">  name: "MSlider",</span></span><br><span class="line"><span class="undefined">  props: &#123;</span></span><br><span class="line"><span class="undefined">    defalutValue: &#123;</span></span><br><span class="line"><span class="undefined">      type: Number,</span></span><br><span class="line"><span class="undefined">      default: 0</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    isVertical: &#123;</span></span><br><span class="line"><span class="undefined">      //if the slider is vertical</span></span><br><span class="line"><span class="undefined">      type: Boolean,</span></span><br><span class="line"><span class="undefined">      default: false</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    steps: &#123;</span></span><br><span class="line"><span class="undefined">      type: Number,</span></span><br><span class="line"><span class="undefined">      default: 1</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    min: &#123;</span></span><br><span class="line"><span class="undefined">      type: Number,</span></span><br><span class="line"><span class="undefined">      default: 0</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    max: &#123;</span></span><br><span class="line"><span class="undefined">      type: Number,</span></span><br><span class="line"><span class="undefined">      default: 100</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  data() &#123;</span></span><br><span class="line"><span class="undefined">    return &#123;</span></span><br><span class="line"><span class="undefined">      vertical: false,</span></span><br><span class="line"><span class="undefined">      draging: false,</span></span><br><span class="line"><span class="undefined">      startX: 0,</span></span><br><span class="line"><span class="undefined">      startPosition: 0,</span></span><br><span class="line"><span class="undefined">      newPosition: 0,</span></span><br><span class="line"><span class="undefined">      oldValue: this.defalutValue,</span></span><br><span class="line"><span class="undefined">      value: this.defalutValue,</span></span><br><span class="line"><span class="undefined">      sliderSize: 1</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  computed: &#123;</span></span><br><span class="line"><span class="undefined">    currentPosition: function() &#123;</span></span><br><span class="line"><span class="undefined">      return `$&#123;((this.value - this.min) / (this.max - this.min)) * 100&#125;%`;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    barStyle: function() &#123;</span></span><br><span class="line"><span class="undefined">      return &#123;</span></span><br><span class="line"><span class="undefined">        width: this.currentPosition,</span></span><br><span class="line"><span class="undefined">        top: 0</span></span><br><span class="line"><span class="undefined">      &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="undefined">    mousedown: function(event) &#123;</span></span><br><span class="line"><span class="undefined">      event.preventDefault();</span></span><br><span class="line"><span class="undefined">      this.onDragStart(event);</span></span><br><span class="line"><span class="undefined">      //register event</span></span><br><span class="line"><span class="undefined">      window.addEventListener("mousemove", this.onDraging);</span></span><br><span class="line"><span class="undefined">      window.addEventListener("mouseup", this.onDragEnd);</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    onDragStart: function(event) &#123;</span></span><br><span class="line"><span class="undefined">      this.draging = true; //start draging</span></span><br><span class="line"><span class="undefined">      this.startX = event.clientX; //get start clientX</span></span><br><span class="line"><span class="undefined">      this.startPosition = parseFloat(this.currentPosition);//convert the string to number</span></span><br><span class="line"><span class="undefined">      this.newPosition = this.startPosition;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    onDraging: function(event) &#123;</span></span><br><span class="line"><span class="undefined">      if (this.draging) &#123;</span></span><br><span class="line"><span class="undefined">        let clientX = event.clientX;</span></span><br><span class="line"><span class="undefined">        //compute the diff of draging.</span></span><br><span class="line"><span class="undefined">        let diff = ((clientX - this.startX) / this.sliderSize) * 100;</span></span><br><span class="line"><span class="undefined">        this.resetSliderSize();</span></span><br><span class="line"><span class="undefined">        this.newPosition = this.startPosition + diff;</span></span><br><span class="line"><span class="undefined">        this.setPosition(this.newPosition);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    onDragEnd: function(event) &#123;</span></span><br><span class="line"><span class="undefined">      this.draging = false;</span></span><br><span class="line"><span class="undefined">      window.removeEventListener("mousemove", this.onDraging);</span></span><br><span class="line"><span class="undefined">      window.removeEventListener("mouseup", this.onDragEnd);</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    onClickJump: function(event) &#123;</span></span><br><span class="line"><span class="undefined">      let offsetLeft = this.$refs.slider.getBoundingClientRect().left;</span></span><br><span class="line"><span class="undefined">      this.setPosition(((event.clientX - offsetLeft) / this.sliderSize) * 100);</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    setPosition: function(newPostion) &#123;</span></span><br><span class="line"><span class="undefined">      if (newPostion &lt; 0) &#123;</span></span><br><span class="line"><span class="undefined">        newPostion = 0;</span></span><br><span class="line"><span class="undefined">      &#125; else if (newPostion &gt; 100) &#123;</span></span><br><span class="line"><span class="undefined">        newPostion = 100;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      //compute the length of one step.</span></span><br><span class="line"><span class="undefined">      let lengthPerSteps = 100 / ((this.max - this.min) / this.steps);</span></span><br><span class="line"><span class="undefined">      //the counts of step</span></span><br><span class="line"><span class="undefined">      let steps = newPostion / lengthPerSteps;</span></span><br><span class="line"><span class="undefined">      //get value,means current position</span></span><br><span class="line"><span class="undefined">      let value =</span></span><br><span class="line"><span class="undefined">        steps * lengthPerSteps * (this.max - this.min) * 0.01 + this.min;</span></span><br><span class="line"><span class="undefined">      this.value = value.toFixed(0);</span></span><br><span class="line"><span class="undefined">      this.oldValue = value;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    resetSliderSize: function() &#123;</span></span><br><span class="line"><span class="undefined">      this.sliderSize = this.$refs.slider[</span></span><br><span class="line"><span class="undefined">        `client$&#123;this.vertical ? "Height" : "Width"&#125;`</span></span><br><span class="line"><span class="undefined">      ];</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  mounted() &#123;</span></span><br><span class="line"><span class="undefined">    this.resetSliderSize();</span></span><br><span class="line"><span class="undefined">    window.addEventListener("resize", this.resetSliderSize);</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  beforeDestroy() &#123;</span></span><br><span class="line"><span class="undefined">    window.removeEventListener("resize", this.resetSliderSize);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>被嫌弃的松子的一生</title>
      <link href="/2018/10/08/%E8%A2%AB%E5%AB%8C%E5%BC%83%E7%9A%84%E6%9D%BE%E5%AD%90%E7%9A%84%E4%B8%80%E7%94%9F/"/>
      <url>/2018/10/08/%E8%A2%AB%E5%AB%8C%E5%BC%83%E7%9A%84%E6%9D%BE%E5%AD%90%E7%9A%84%E4%B8%80%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>国庆放假看完了中岛哲也导演的《被嫌弃的松子的一生》。不由的想到我的一生会是怎么样呢？<br>每个人的一生会过的怎么样都会和自己的性格有关系吧。性格怎么养成又和所成长的环境有莫大的关系。<br>松子看着父亲总是因为小妹的病情一筹莫展，更加觉得父亲喜爱小妹胜过自己，故而总是想讨得父亲的欢心。<br>突然发现自己扮丑可以令父亲开怀大笑，总是这样做以讨父亲欢心。<br>我又想到了太宰治写的《人间失格》中叶藏亦是如此，因为童年的遭遇总是假装幽默风趣以博得周围人的笑容。<br>我呢？我也是这样的吧。我不想笑，我也会假装很开心。以至于大家都会认为我幽默风趣，开朗活泼。也就只有我自己知道我是一个什么德行。<br>看到松子因为小时候缺爱以至于长大后一直在寻找被爱的感觉。尽管一直被伤害，她也不想放弃的。<br>第一个男朋友是一位作家，经常殴打她伤害她，甚至后来还在松子眼前自杀，松子也没想过去当浴室女郎。后来被男友对立面的作家骗的当了情妇，发现自己被利用就开始自暴自弃了。<br>做过浴室女郎，后来又和一个搭讪自己的男人合伙做生意，被骗财骗色，杀了他。<br>她觉得还是只有第一个男朋友最爱她，所以她要去找他，男朋友最喜欢的作家是太宰治，故而想去太宰治自杀的地方自杀，她说这样就可以找到那个最爱她的人了。<br>却在去自杀的路上遇到了一个老实憨厚的理发师，理发师给了她爱，又决定跟着理发师安稳的度过下半辈子，却还是因为杀人罪被抓，八年后出狱回来找理发师却发现理发师已经结婚生子。<br>自己心心念念的人儿，早已忘了她。只有她自己傻傻的还记着呢？或许当时心灰意冷了吧。松子还是走了，她不想打扰理发师的生活。亦或者她骄傲的自尊心不允许她这么做。<br>后来以为可以和学生相守一生，没想到学生入狱，出来也和松子分手了。<br>松子幡然醒悟，这世上不会有人爱她。<br>在一条和家乡河流很相似的河流对岸租了一个房子。每天坐在那，看着夕阳西下，看着流动的河水，可能在想自己小时候的事情，亦或者在回顾自己的一生。<br>松子一生都是在被骗被伤害，她只不过是想找到一个爱自己的人，她做错了什么？以至于最后都不再相信世上也会有人爱她，可是最爱她的还是她自己，她却不知道。她自暴自弃，每天窝在出租屋，吃着快餐喝着啤酒，发疯的时候在墙上写下了“生而为人，我很抱歉”的话。<br>或许她是清醒的，只是不想再面对这样的生活。最后被一群小混混乱棍打死。<br>松子她不爱惜自己，她的一生就变成这样了。<br>我呢？曾经我也试图让周围的人开心，我把所有的不满委屈都深深的隐藏，总是担心别人对自己不满意，后来忍受不了就咬自己的胳膊。我想我是疯了。<br>但我也有清醒的时候，我知道我的一生我不能这样，别人不是我的天，我有自己的生活，我们都要争取做最爱自己的人。<br>我不想说“生而为人，我很抱歉”的话，或许不会轰轰烈烈，但至少安稳。</p>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>中秋日记</title>
      <link href="/2018/09/26/%E4%B8%AD%E7%A7%8B%E6%97%A5%E8%AE%B0/"/>
      <url>/2018/09/26/%E4%B8%AD%E7%A7%8B%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>娇娇在节前一天就约我放假后叫上贝贝一起玩密室逃脱，我应允了，我知道我自己放假不出门必然会窝在屋里玩游戏的。<br>娇娇和贝贝是我刚毕业来北京工作的第一家公司的同事。<br>刚来的时候谁都不认识，本就不是一个主动的人，当然不敢见谁都跑上去打招呼，总是一个人到处瞎溜达。<br>刚来北京总是觉得北京的饭菜难吃的要命，所以每天自己做饭，做晚饭带中饭。其实一直到现在都觉得北京的饭菜难吃，只不过能凑合的吃了，也只是为自己不做饭找个借口罢了。<br>娇娇和贝贝她们也是带饭队伍中的一员。当然，我也只是见到过她们，从来不会上去打招呼的。<br>有天早上在公交车上碰到贝贝，一眼就在人群中认出了贝贝，为啥呢？眼缘很重要。可是我不敢上去拍她的肩膀说“hi”。我就这样悄无声息的错了一个搭讪的机会。<br>上帝知道我不是一个主动的人，白白浪费了他为我俩创造的机会，估计恨铁不成钢啊，可是能怎么着呢？剧本安排我得跟着贝贝混，无奈又得为我俩创造一个认识的机会，可是这次的安排是让贝贝来搭讪我。事发在咱俩搬家到公司附近的同一个小区的一个早上，在上班路上又碰到了，咱俩一前一后的走着，她突然跑上去叫我的名字，我当然很诧异怎么会知道我名字呢？不过没问出口。咱俩有一搭没一搭的聊着一路走到了公司。特别清楚的记得那天中午贝贝叫我一块吃中饭，从那天开始我就跟着贝贝混了，每天中午一起吃饭，当然，还有娇娇，我们就成了饭友。每天中午都会聊着各种各样的趣事，大家一起捧腹大笑。我只能说她俩的笑点真低，把我的笑点也拉低了。我竟然觉得上班的日子也不是那么的百般无聊了，每天也会有一丝丝的小期待吃饭的时刻。因为我不在是一个人啦，我也有我的小伙伴了。后来贝贝离职后，只剩我和娇娇相依为命了。再到后来，我也离职了，只剩娇娇一个人孤苦无依了。<br>尽管不在一起工作，但我们还是会相约在一起看星星看月亮。<br>后来娇娇生了小耳朵，我们会相约在一起看耳朵，但这样的机会也屈指可数。<br>在约好的时间内我没按时到，晚了几分钟，娇娇她们先去密室了，我到了之后直接进入第二关，看的她们还在第一关冥思苦想呢，虽然只隔着一扇铁门，我也要假象她们是来救我的。我在第二关摆弄着扑克牌，百般无聊就开始锤四面墙，忽然从头顶飘来一句警告“不要锤墙”，我了个怕啊，只能乖乖的等着娇娇她们来和我汇合。看着她们三互相推脱选谁来发求救信号，不管用了什么方式，总之成功的进入到了第二关，百万雄师过大江终于汇合啦。我压抑着内心的小激动，哎哟妈呀，终于来救我了。可是站在第二关面前，大家大眼瞪小眼，有点尴尬，又选谁来发求救信号呢？嗯。娇娇家的五花肉出场啦。得到答案后，五花肉那个捶胸顿足，为啥呢？因为我们离答案只差一步了。终于来了第三关了，研究半天也没找到答案拿到钥匙，没想到五花肉这货竟然把人锁在小盒子的钥匙给摇出来了，厉害的。欣喜若狂的拿着钥匙打开了另一个盒子。我也在旁边瞎捣鼓呢，竟然解开了密码，但是我不知道啊，最后贝贝发现了，成功又拿到了一个钥匙。接下来又该大眼瞪小眼了，到求救的时刻啦。嗯，反正最后我们是出来了。总结出来就是我们脑洞不够大。<br>费了些许脑力，我们饿呀，在娇娇和五花肉的带领下，我吃到了久违许久的热干面。<br>晚上自然是在娇娇家玩耍，我们商量着是玩扑克呢还是玩决门？决门是个啥呢？这事得从几年前开始说起，那是娇娇第一次玩三国杀，三国杀有张牌是决斗，牌面写的“決鬥”，娇娇理所当然的认为是“決门”。嗯，我当然憋住不笑。可是娇娇家的五花肉忍不住啊，他笑出了声。自此决门这个梗一直跟着娇娇。最终我们决定玩扑克牌。<br>贝贝说不会玩，我们就慢慢教她，可是我发现她不止不会玩，她也不会放牌，她老是把牌放在我面前，我不想看都不行。自然我是不会输的。当然还有娇娇家的五花肉，他每次摸完牌都会说“尼玛”，还带着声调的拖着尾音的说，我们就知道他的牌不差，故意放烟雾弹给我们呢。他不仅给我们放烟雾弹，还放屁呢，用娇娇的话说这是在开拖拉机。<br>其实我也想放屁，只是不好意思的放，用力的憋着，后来憋不住啦，索性就放出来了。隔着屏幕都能闻到浓浓的臭味。不想说了。<br>睡醒后的第二天吃过早饭又接着玩扑克，吃火锅。开心的度过一天。但是贝贝却认为我们是堕落的度过了一天，她老是吵着要回家写代码，她是codegirl，love coding。<br>记了这么久的流水账，只是想说和娇娇她们一起玩挺开心的，真的开心，因为不管说什么总是大家一起笑，虽然有时候我也不知道她们在笑什么，但看到她们笑我也想笑。<br>最后临走时又厚着脸皮的在娇娇家抱走了两个大柚子。<br>全剧终。</p>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 朋友 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1Q84</title>
      <link href="/2018/09/17/1Q84/"/>
      <url>/2018/09/17/1Q84/</url>
      
        <content type="html"><![CDATA[<p>未完待续。</p>]]></content>
      
      
      <categories>
          
          <category> 书迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科幻 </tag>
            
            <tag> 村上春树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秘密</title>
      <link href="/2018/09/17/%E7%A7%98%E5%AF%86/"/>
      <url>/2018/09/17/%E7%A7%98%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>未完待续。</p>]]></content>
      
      
      <categories>
          
          <category> 书迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 东野圭吾 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>恶意</title>
      <link href="/2018/09/17/%E6%81%B6%E6%84%8F/"/>
      <url>/2018/09/17/%E6%81%B6%E6%84%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 书迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 东野圭吾 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>时生</title>
      <link href="/2018/09/17/%E6%97%B6%E7%94%9F/"/>
      <url>/2018/09/17/%E6%97%B6%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>拓实夫妇在明知道基因缺陷病会遗传给孩子的情况下，坚持生下了时生。本抱着侥幸的心里希望时生能健健康康度过这一生，可天不遂人愿，时生终究还是住进了ICU，看着孩子躺在病床上的模样，拓实太太终究还是不敢问出来“有没有‘来到世上真好’的感觉？幸福吗？恨不恨我们？”，拓实告诉太太“时生不曾这样想过”。<br>或许丽子认为这是拓实安慰她的话，但拓实他却说在他23岁的时候就遇到了儿子时生。<br>拓实讲诉自己年轻的时候是一个游手好闲靠女人养活的混蛋，遇到儿子时生后，在时生的帮助下生活渐渐改善，性格受到诚实稳重的时生的影响也有所改变。<br>我被父子之间的感情感染到了，书末时生在生命的尽头告诉父母“他并不后悔做父母亲的孩子，这19年来他过的很幸福”，我竟然潸然泪下。<br>为什么？<br>因为我从小就羡慕别人家有这样的父亲。我的父亲脾气暴躁，说他自私毫不为过。他总是认为自己是对的，绝不认为自己错。印象中一直对母亲动手。每每看到母亲被揍的毫无还手之力时，我对自己的无能为力感到不快。所以我对打女人的男人有深深的仇恨感，我恨不能杀之而后快。<br>我的童年没有时生幸福，没有相亲相爱的一家人。<br>随着年岁的渐长，仇恨感日见增多，或者我也是害怕的。不敢和父亲四目相对，总是在躲避他。<br>高中时父亲对我说的最多的一句话就是“不准结交任何男同学”。但身处叛逆期的我怎么会如此听话呢？我偏要结交很多男同学。<br>每次回家都会把手机通讯录的名单清理一遍，把号码誊写在小本本上，任由父亲检查翻看我的手机，一丁点蛛丝马迹都不留给你。<br>当然，大学不会考到一个很好的大学，只能上一个三本本科。一年学费一万呢，但父亲依然坚持让我上。尽管其他叔叔伯伯都觉得没必要，可是我父亲的决定怎能轻易改变呢？<br>即使他让我上了大学，也丝毫不减我对他的仇恨。<br>我从不给他打电话，但是他每周都会给我打电话，我跟他也无话可说，基本都是他问我答，一直到我工作后，每周给我打电话的习惯都不变。可是我害怕呀，我不想接电话的，我不想面对他，但是如果我不接电话他就会骂我不感恩的白眼狼。<br>很多年后我才明白那个时候他的心情，他只是不会表达，他只是担心我，如果我不接电话他就害怕我出事，所以会一直给我打电话直到我接，他只能通过骂我吼我才能缓解他对我的担心之情。<br>现在换我每天给父母打电话，如果他们不接电话，我也会担心他们出事。只有接了电话才会觉得安心。<br>我现在还恨父亲么？不恨了，早在他坚持让我上大学的时候我就不该恨他的。我应该早点知道他其实很关心我的。关心则乱这句话没错，所以他才会那么生气的吼我骂我，他不知道如何表达对我的关心。<br>幸好现在还来得及，他没事了。<br>往后余生，只希望父母健健康康平平安安相守一生。</p>]]></content>
      
      
      <categories>
          
          <category> 书迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 东野圭吾 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1984</title>
      <link href="/2018/09/12/1984/"/>
      <url>/2018/09/12/1984/</url>
      
        <content type="html"><![CDATA[<p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> 书迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乔治奥威尔 </tag>
            
            <tag> 科幻 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>夏天·烟火·我的尸体</title>
      <link href="/2018/09/12/%E5%A4%8F%E5%A4%A9%C2%B7%E7%83%9F%E7%81%AB%C2%B7%E6%88%91%E7%9A%84%E5%B0%B8%E4%BD%93/"/>
      <url>/2018/09/12/%E5%A4%8F%E5%A4%A9%C2%B7%E7%83%9F%E7%81%AB%C2%B7%E6%88%91%E7%9A%84%E5%B0%B8%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>洪啸老早就推荐我看这本书。最近才有时间看。看完之后突然想到曾经看到的一句话“恶之天真，天真之恶”。小孩子真的是很纯真的么？我不信。他们肯定也有邪恶的一面。只是他们不知道他们的这个行为会造成多么严重的后果。</p><p>书中的弥生在伸手推五月的时候，她应该没想过五月会这么被摔死。所以她害怕了。她不知所措。幸好她还有阿健，她的哥哥，她最喜欢的哥哥。所以她不容许别人也喜欢她的哥哥，就是因为五月偷偷告诉她喜欢阿健，她心里嫉妒，所以对五月伸出了魔掌，让五月从树上摔下去。</p><p>阿健和弥生一起藏五月的尸体，阿健说“别怕，有我在”。我想弥生会不会有那么一点庆幸？所以她和阿健才会能这么亲密。从头到尾，我都在怀疑，是不是我理解错了？弥生她不是读小学三年级，应该是读初中三年级或者更大。而阿健他不是小学六年级。可是作者明明白白的写着当暑假结束，弥生重新回到小学，她该上三年级了。</p><p>想起小时候的自己也干过一堆坏事。和隔壁小朋友一起玩跷跷板，故意让他捡一块砖头放在跷跷板那头，我在他放砖头到跷跷板那头时趁机踩下了跷跷板这头，我明知道我这一脚才下去，砖头会迎面拍在他脸上，但我还是踩了，我只想知道会把他拍成什么样，他哭了，鼻子一直在流血，而我却在哈哈大笑，后面的记不清了，只知道他再也没和我一起玩了。</p><p>现在回想起来，也没法理解当时为什么要这么做，只是觉得好玩吧，也不会觉得会把他拍成什么样，更加没想过“死”这个字眼，当然，很庆幸没有和这个字相关。</p>]]></content>
      
      
      <categories>
          
          <category> 书迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑乙一 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原型</title>
      <link href="/2018/09/12/%E5%8E%9F%E5%9E%8B/"/>
      <url>/2018/09/12/%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>【未完待续】</p>]]></content>
      
      
      <categories>
          
          <category> 程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
